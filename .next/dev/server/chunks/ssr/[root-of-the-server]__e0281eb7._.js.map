{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bolad/Downloads/SoloBotAgency_SaaS_Starter/lib/usage.ts"],"sourcesContent":["import { getFirestore, doc, getDoc, setDoc, updateDoc, increment } from \"firebase/firestore\";\r\nimport { initializeApp, getApps, getApp } from \"firebase/app\";\r\n\r\n// 1. Safe Configuration Parsing\r\nconst configStr = process.env.NEXT_PUBLIC_FIREBASE_CONFIG;\r\nlet firebaseConfig;\r\n\r\ntry {\r\n  firebaseConfig = configStr ? JSON.parse(configStr) : null;\r\n} catch (e) {\r\n  console.error(\"Firebase Config JSON parse error:\", e);\r\n  firebaseConfig = null;\r\n}\r\n\r\n// 2. Safe Initialization (Singleton)\r\nlet app;\r\nlet db: any;\r\n\r\nif (firebaseConfig && firebaseConfig.projectId) {\r\n  try {\r\n    app = getApps().length > 0 ? getApp() : initializeApp(firebaseConfig);\r\n    db = getFirestore(app);\r\n  } catch (e) {\r\n    console.error(\"Firebase initialization failed:\", e);\r\n  }\r\n} else {\r\n  console.warn(\"⚠️ Firebase Config missing or invalid. Usage tracking will be mocked.\");\r\n}\r\n\r\nexport const FREE_LIMIT = 3;\r\n\r\n// Helper to get usage ref safely\r\nconst getUsageRef = (userId: string) => {\r\n  if (!db) return null;\r\n  const appId = process.env.NEXT_PUBLIC_APP_ID || \"default-app\";\r\n  return doc(db, \"artifacts\", appId, \"users\", userId, \"usage\", \"sales-agent\");\r\n};\r\n\r\nexport async function getUsage(userId: string) {\r\n  // Fail safe if DB isn't connected\r\n  if (!db) return { count: 0 };\r\n\r\n  try {\r\n    const usageRef = getUsageRef(userId);\r\n    if (!usageRef) return { count: 0 };\r\n\r\n    const snapshot = await getDoc(usageRef);\r\n\r\n    if (snapshot.exists()) {\r\n      return { count: snapshot.data().count || 0 };\r\n    }\r\n    \r\n    // Create default if not exists\r\n    await setDoc(usageRef, { count: 0 });\r\n    return { count: 0 };\r\n  } catch (error) {\r\n    console.error(\"Error fetching usage:\", error);\r\n    return { count: 0 };\r\n  }\r\n}\r\n\r\nexport async function incrementUsage(userId: string) {\r\n  if (!db) return 0;\r\n\r\n  try {\r\n    const usageRef = getUsageRef(userId);\r\n    if (!usageRef) return 0;\r\n\r\n    const snapshot = await getDoc(usageRef);\r\n\r\n    if (!snapshot.exists()) {\r\n      await setDoc(usageRef, { count: 1 });\r\n      return 1;\r\n    } else {\r\n      await updateDoc(usageRef, { count: increment(1) });\r\n      return (snapshot.data().count || 0) + 1;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error incrementing usage:\", error);\r\n    return 0;\r\n  }\r\n}"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AAAA;;;AAEA,gCAAgC;AAChC,MAAM,YAAY,QAAQ,GAAG,CAAC,2BAA2B;AACzD,IAAI;AAEJ,IAAI;IACF,iBAAiB,YAAY,KAAK,KAAK,CAAC,aAAa;AACvD,EAAE,OAAO,GAAG;IACV,QAAQ,KAAK,CAAC,qCAAqC;IACnD,iBAAiB;AACnB;AAEA,qCAAqC;AACrC,IAAI;AACJ,IAAI;AAEJ,IAAI,kBAAkB,eAAe,SAAS,EAAE;IAC9C,IAAI;QACF,MAAM,IAAA,2KAAO,IAAG,MAAM,GAAG,IAAI,IAAA,0KAAM,MAAK,IAAA,iLAAa,EAAC;QACtD,KAAK,IAAA,iLAAY,EAAC;IACpB,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,mCAAmC;IACnD;AACF,OAAO;IACL,QAAQ,IAAI,CAAC;AACf;AAEO,MAAM,aAAa;AAE1B,iCAAiC;AACjC,MAAM,cAAc,CAAC;IACnB,IAAI,CAAC,IAAI,OAAO;IAChB,MAAM,QAAQ,mDAAkC;IAChD,OAAO,IAAA,wKAAG,EAAC,IAAI,aAAa,OAAO,SAAS,QAAQ,SAAS;AAC/D;AAEO,eAAe,SAAS,MAAc;IAC3C,kCAAkC;IAClC,IAAI,CAAC,IAAI,OAAO;QAAE,OAAO;IAAE;IAE3B,IAAI;QACF,MAAM,WAAW,YAAY;QAC7B,IAAI,CAAC,UAAU,OAAO;YAAE,OAAO;QAAE;QAEjC,MAAM,WAAW,MAAM,IAAA,2KAAM,EAAC;QAE9B,IAAI,SAAS,MAAM,IAAI;YACrB,OAAO;gBAAE,OAAO,SAAS,IAAI,GAAG,KAAK,IAAI;YAAE;QAC7C;QAEA,+BAA+B;QAC/B,MAAM,IAAA,2KAAM,EAAC,UAAU;YAAE,OAAO;QAAE;QAClC,OAAO;YAAE,OAAO;QAAE;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO;YAAE,OAAO;QAAE;IACpB;AACF;AAEO,eAAe,eAAe,MAAc;IACjD,IAAI,CAAC,IAAI,OAAO;IAEhB,IAAI;QACF,MAAM,WAAW,YAAY;QAC7B,IAAI,CAAC,UAAU,OAAO;QAEtB,MAAM,WAAW,MAAM,IAAA,2KAAM,EAAC;QAE9B,IAAI,CAAC,SAAS,MAAM,IAAI;YACtB,MAAM,IAAA,2KAAM,EAAC,UAAU;gBAAE,OAAO;YAAE;YAClC,OAAO;QACT,OAAO;YACL,MAAM,IAAA,8KAAS,EAAC,UAAU;gBAAE,OAAO,IAAA,8KAAS,EAAC;YAAG;YAChD,OAAO,CAAC,SAAS,IAAI,GAAG,KAAK,IAAI,CAAC,IAAI;QACxC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACT;AACF"}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bolad/Downloads/SoloBotAgency_SaaS_Starter/lib/stripe.ts"],"sourcesContent":["import { stripe } from \"@/lib/stripe\";\nimport { auth } from \"@clerk/nextjs/server\";\n\n/**\n * Reads the user's subscription status from Stripe.\n * Returns { isPremium: boolean, plan: string | null }\n */\nexport async function getUserSubscriptionStatus(userId: string) {\n  if (!userId) {\n    return { isPremium: false, plan: null };\n  }\n\n  // Look up Stripe customer by Clerk userId (saved in metadata)\n  const customers = await stripe.customers.list({\n    limit: 1,\n    expand: [\"data.subscriptions\"],\n    email: auth()?.user?.emailAddresses?.[0]?.emailAddress,\n  });\n\n  const customer = customers.data[0];\n  if (!customer) {\n    return { isPremium: false, plan: null };\n  }\n\n  // Extract active subscription\n  const subscriptions = customer.subscriptions?.data || [];\n  const activeSub = subscriptions.find(\n    (sub) => sub.status === \"active\" || sub.status === \"trialing\"\n  );\n\n  if (!activeSub) {\n    return { isPremium: false, plan: null };\n  }\n\n  return {\n    isPremium: true,\n    plan: activeSub.items.data[0]?.price.product || \"pro\",\n  };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,eAAe,0BAA0B,MAAc;IAC5D,IAAI,CAAC,QAAQ;QACX,OAAO;YAAE,WAAW;YAAO,MAAM;QAAK;IACxC;IAEA,8DAA8D;IAC9D,MAAM,YAAY,MAAM,uHAAM,CAAC,SAAS,CAAC,IAAI,CAAC;QAC5C,OAAO;QACP,QAAQ;YAAC;SAAqB;QAC9B,OAAO,IAAA,2LAAI,KAAI,MAAM,gBAAgB,CAAC,EAAE,EAAE;IAC5C;IAEA,MAAM,WAAW,UAAU,IAAI,CAAC,EAAE;IAClC,IAAI,CAAC,UAAU;QACb,OAAO;YAAE,WAAW;YAAO,MAAM;QAAK;IACxC;IAEA,8BAA8B;IAC9B,MAAM,gBAAgB,SAAS,aAAa,EAAE,QAAQ,EAAE;IACxD,MAAM,YAAY,cAAc,IAAI,CAClC,CAAC,MAAQ,IAAI,MAAM,KAAK,YAAY,IAAI,MAAM,KAAK;IAGrD,IAAI,CAAC,WAAW;QACd,OAAO;YAAE,WAAW;YAAO,MAAM;QAAK;IACxC;IAEA,OAAO;QACL,WAAW;QACX,MAAM,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,WAAW;IAClD;AACF"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bolad/Downloads/SoloBotAgency_SaaS_Starter/lib/subscription.ts"],"sourcesContent":["import { currentUser } from \"@clerk/nextjs/server\";\r\nimport { stripe } from \"@/lib/stripe\";\r\n\r\n/**\r\n * Reads the user's subscription status from Stripe.\r\n * Returns { isPremium: boolean, plan: string | null }\r\n */\r\nexport async function getUserSubscriptionStatus(userId: string) {\r\n  try {\r\n    // 1. Get User Email from Clerk\r\n    const user = await currentUser();\r\n    \r\n    if (!userId || !user) {\r\n      return { isPremium: false, plan: null };\r\n    }\r\n\r\n    const email = user.emailAddresses[0]?.emailAddress;\r\n    if (!email) {\r\n      return { isPremium: false, plan: null };\r\n    }\r\n\r\n    // 2. ADMIN BYPASS (Critical for testing)\r\n    if (email === \"solobotagency@gmail.com\") {\r\n      return { isPremium: true, plan: \"ADMIN\" };\r\n    }\r\n\r\n    // 3. Look up Stripe customer by email\r\n    const customers = await stripe.customers.list({\r\n      limit: 1,\r\n      email: email,\r\n      expand: [\"data.subscriptions\"],\r\n    });\r\n\r\n    const customer = customers.data[0];\r\n    if (!customer) {\r\n      return { isPremium: false, plan: null };\r\n    }\r\n\r\n    // 4. Extract active subscription\r\n    const subscriptions = customer.subscriptions?.data || [];\r\n    const activeSub = subscriptions.find(\r\n      (sub) => sub.status === \"active\" || sub.status === \"trialing\"\r\n    );\r\n\r\n    if (!activeSub) {\r\n      return { isPremium: false, plan: null };\r\n    }\r\n\r\n    // 5. Return Status\r\n    return {\r\n      isPremium: true,\r\n      // Use nickname if available, otherwise default to \"PRO\"\r\n      plan: activeSub.items.data[0]?.price.nickname || \"PRO\", \r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error checking subscription:\", error);\r\n    return { isPremium: false, plan: null };\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,eAAe,0BAA0B,MAAc;IAC5D,IAAI;QACF,+BAA+B;QAC/B,MAAM,OAAO,MAAM,IAAA,yMAAW;QAE9B,IAAI,CAAC,UAAU,CAAC,MAAM;YACpB,OAAO;gBAAE,WAAW;gBAAO,MAAM;YAAK;QACxC;QAEA,MAAM,QAAQ,KAAK,cAAc,CAAC,EAAE,EAAE;QACtC,IAAI,CAAC,OAAO;YACV,OAAO;gBAAE,WAAW;gBAAO,MAAM;YAAK;QACxC;QAEA,yCAAyC;QACzC,IAAI,UAAU,2BAA2B;YACvC,OAAO;gBAAE,WAAW;gBAAM,MAAM;YAAQ;QAC1C;QAEA,sCAAsC;QACtC,MAAM,YAAY,MAAM,uHAAM,CAAC,SAAS,CAAC,IAAI,CAAC;YAC5C,OAAO;YACP,OAAO;YACP,QAAQ;gBAAC;aAAqB;QAChC;QAEA,MAAM,WAAW,UAAU,IAAI,CAAC,EAAE;QAClC,IAAI,CAAC,UAAU;YACb,OAAO;gBAAE,WAAW;gBAAO,MAAM;YAAK;QACxC;QAEA,iCAAiC;QACjC,MAAM,gBAAgB,SAAS,aAAa,EAAE,QAAQ,EAAE;QACxD,MAAM,YAAY,cAAc,IAAI,CAClC,CAAC,MAAQ,IAAI,MAAM,KAAK,YAAY,IAAI,MAAM,KAAK;QAGrD,IAAI,CAAC,WAAW;YACd,OAAO;gBAAE,WAAW;gBAAO,MAAM;YAAK;QACxC;QAEA,mBAAmB;QACnB,OAAO;YACL,WAAW;YACX,wDAAwD;YACxD,MAAM,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,YAAY;QACnD;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;YAAE,WAAW;YAAO,MAAM;QAAK;IACxC;AACF"}},
    {"offset": {"line": 303, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/bolad/Downloads/SoloBotAgency_SaaS_Starter/app/dashboard/ai-sales-agent/lib/paywall.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { auth } from \"@clerk/nextjs/server\";\r\nimport { FREE_LIMIT, getUsage, incrementUsage as incrementUsageDb } from \"@/lib/usage\";\r\nimport { getUserSubscriptionStatus } from \"@/lib/subscription\";\r\nimport { stripe } from \"@/lib/stripe\";\r\nimport { redirect } from \"next/navigation\";\r\n\r\n// 1. CHECK USAGE STATUS\r\nexport async function checkUsage() {\r\n  const { userId } = auth();\r\n  \r\n  // If not logged in, return locked state (safe default)\r\n  if (!userId) {\r\n    return { usage: 0, remaining: 0, limit: FREE_LIMIT, isLocked: true, isPremium: false };\r\n  }\r\n\r\n  // Check Subscription Status (Handles Admin Bypass internally)\r\n  const subscription = await getUserSubscriptionStatus(userId);\r\n\r\n  // PREMIUM / ADMIN LOGIC -> UNLIMITED ACCESS\r\n  if (subscription.isPremium) {\r\n    return {\r\n      usage: 0,\r\n      remaining: 9999, // Infinite for UI display\r\n      limit: FREE_LIMIT,\r\n      isLocked: false,\r\n      isPremium: true,\r\n      plan: subscription.plan,\r\n    };\r\n  }\r\n\r\n  // FREE TIER LOGIC -> CHECK FIREBASE USAGE\r\n  const usage = await getUsage(userId);\r\n  const currentCount = usage.count || 0;\r\n\r\n  const remaining = Math.max(0, FREE_LIMIT - currentCount);\r\n  const isLocked = currentCount >= FREE_LIMIT;\r\n\r\n  return {\r\n    usage: currentCount,\r\n    remaining,\r\n    limit: FREE_LIMIT,\r\n    isLocked,\r\n    isPremium: false,\r\n  };\r\n}\r\n\r\n// 2. INCREMENT USAGE\r\nexport async function incrementUsage() {\r\n  const { userId } = auth();\r\n  if (!userId) return;\r\n\r\n  const subscription = await getUserSubscriptionStatus(userId);\r\n\r\n  // Premium users do NOT increment usage count\r\n  if (subscription.isPremium) return;\r\n\r\n  await incrementUsageDb(userId);\r\n}\r\n\r\n// 3. TRACK USAGE (Alias for compatibility with page.tsx)\r\nexport async function trackUsage() {\r\n  await incrementUsage();\r\n}\r\n\r\n// 4. CREATE CHECKOUT SESSION\r\nexport async function createCheckoutSession() {\r\n  const { userId } = auth();\r\n  if (!userId) return;\r\n\r\n  // ✅ FIX: Use the correct environment variable\r\n  const priceId = process.env.STRIPE_PRO_MONTHLY_PRICE_ID;\r\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\r\n\r\n  if (!priceId) {\r\n    console.error(\"❌ Configuration Error: STRIPE_PRO_MONTHLY_PRICE_ID is missing.\");\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const session = await stripe.checkout.sessions.create({\r\n      mode: \"subscription\",\r\n      payment_method_types: [\"card\"],\r\n      line_items: [\r\n        {\r\n          price: priceId,\r\n          quantity: 1,\r\n        },\r\n      ],\r\n      // Metadata allows linking the session back to the user later if needed\r\n      metadata: {\r\n        userId: userId,\r\n      },\r\n      success_url: `${appUrl}/dashboard/ai-sales-agent?success=true`,\r\n      cancel_url: `${appUrl}/dashboard/ai-sales-agent?canceled=true`,\r\n    });\r\n\r\n    if (session.url) {\r\n      redirect(session.url);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Stripe session creation failed\", error);\r\n    // Fallback redirect if Stripe fails\r\n    redirect(\"/dashboard/billing\");\r\n  }\r\n}"],"names":[],"mappings":";;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;AAGO,eAAe;IACpB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,2LAAI;IAEvB,uDAAuD;IACvD,IAAI,CAAC,QAAQ;QACX,OAAO;YAAE,OAAO;YAAG,WAAW;YAAG,OAAO,0HAAU;YAAE,UAAU;YAAM,WAAW;QAAM;IACvF;IAEA,8DAA8D;IAC9D,MAAM,eAAe,MAAM,IAAA,gJAAyB,EAAC;IAErD,4CAA4C;IAC5C,IAAI,aAAa,SAAS,EAAE;QAC1B,OAAO;YACL,OAAO;YACP,WAAW;YACX,OAAO,0HAAU;YACjB,UAAU;YACV,WAAW;YACX,MAAM,aAAa,IAAI;QACzB;IACF;IAEA,0CAA0C;IAC1C,MAAM,QAAQ,MAAM,IAAA,wHAAQ,EAAC;IAC7B,MAAM,eAAe,MAAM,KAAK,IAAI;IAEpC,MAAM,YAAY,KAAK,GAAG,CAAC,GAAG,0HAAU,GAAG;IAC3C,MAAM,WAAW,gBAAgB,0HAAU;IAE3C,OAAO;QACL,OAAO;QACP;QACA,OAAO,0HAAU;QACjB;QACA,WAAW;IACb;AACF;AAGO,eAAe;IACpB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,2LAAI;IACvB,IAAI,CAAC,QAAQ;IAEb,MAAM,eAAe,MAAM,IAAA,gJAAyB,EAAC;IAErD,6CAA6C;IAC7C,IAAI,aAAa,SAAS,EAAE;IAE5B,MAAM,IAAA,8HAAgB,EAAC;AACzB;AAGO,eAAe;IACpB,MAAM;AACR;AAGO,eAAe;IACpB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,2LAAI;IACvB,IAAI,CAAC,QAAQ;IAEb,8CAA8C;IAC9C,MAAM,UAAU,QAAQ,GAAG,CAAC,2BAA2B;IACvD,MAAM,SAAS,QAAQ,GAAG,CAAC,mBAAmB,IAAI;IAElD,IAAI,CAAC,SAAS;QACZ,QAAQ,KAAK,CAAC;QACd;IACF;IAEA,IAAI;QACF,MAAM,UAAU,MAAM,uHAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YACpD,MAAM;YACN,sBAAsB;gBAAC;aAAO;YAC9B,YAAY;gBACV;oBACE,OAAO;oBACP,UAAU;gBACZ;aACD;YACD,uEAAuE;YACvE,UAAU;gBACR,QAAQ;YACV;YACA,aAAa,GAAG,OAAO,sCAAsC,CAAC;YAC9D,YAAY,GAAG,OAAO,uCAAuC,CAAC;QAChE;QAEA,IAAI,QAAQ,GAAG,EAAE;YACf,IAAA,iMAAQ,EAAC,QAAQ,GAAG;QACtB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,oCAAoC;QACpC,IAAA,iMAAQ,EAAC;IACX;AACF;;;IAjGsB;IAwCA;IAaA;IAKA;;AA1DA,+OAAA;AAwCA,+OAAA;AAaA,+OAAA;AAKA,+OAAA"}}]
}